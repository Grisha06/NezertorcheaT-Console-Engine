# NezertorcheaT Console Engine

## Приветствую вас в документации по NezertorcheaT Console Engine!

И начнём пожалуй с того, что, чтобы работать, вам потребуется установленный Python на компьютер, и закачанный репозиторий самого проекта, в отдельной папке.  

Чтобы попробовать тестовый проект, запустите файл main.py. 

Редактор карты открывается запуском файла redactor.py.  
Поля "**Height**" и "**Width**" отвечают за размер игрового поля.  
Написав туда цифры больше 1 и нажав "**Set Grid Size**" вы сохраните эти значения в файл globalSettings.json.  
Кнопка "**Save Map**" сохранит карту в файл globalMap.json.  
Нажимая на клетки откроется меню создания объекта, но сначала нужно вписать туда имя одного из классов лежащих в папке
Scripts.

Далее будет окно редактора свойств, в нём обязательно должны быть свойства: "**name**", "**spawnposx**", "**spawnposy**"
, "**symbol**", "**parent**"
и "**collide**". Так же вы сами можете добавить эти свойства в скриптах.

Свойство "**name**" отвечает за имя и если введённое имя существует, объект с этим именем будет перезаписан.  
Свойство "**spawnposx**" отвечает за начальную локальною позицию объекта по оси X.  
Свойство "**spawnposy**" отвечает за начальную локальною позицию объекта по оси Y.  
Свойство "**symbol**" отвечает за символ объекта в мире.  
Свойство "**collide**" отвечает за возможность столкновения с другими объектами.  
Свойство "**parent**" отвечает за родителя объекта и принимает имя объекта.  
Свойство с окончанием "**_name**" принимает имя объекта и будет рассмотрено как этот объект.  
Кнопка "**Save**" отвечает за сохранение объекта на карте.

Это пока весь функционал редактора карты.

## Теперь самое интересное! Cвои скрипты!

В папке Scripts вы можете создавать свои файлы, по подобию имеющихся. Ваш скрипт должен выглядеть вот так:

```
#<imports>
from NTEngineClasses import *  

class Name(Behavior):
    spawnposx = 0  
    spawnposy = 0  
    symbol = '@'  
    collide = True

    def start(self):  
        #<code>  
    
    def update(self, a):  
        #<code>  
        if not self.isInstantiated:  
            #<ui_code>  
    def onCollide(self, collider: Transform):
        pass
    def lateUpdate(self, a):
        Drawer().drawSymb(a, "8", Vec3(1, 1))
        
```  

### Объяснение методов:

1. NTETime:
    - **getTime()** - возвращает текущий кадр
2. ObjList:
    - **getObj(i: int)** - получить объект
    - **getObjs()** - получить все объекты
    - **getObjByName(name: str)** - получить объект с именем "name"
    - **getObjsByBeh(btype):** - получить все объекты с типом "btype"
3. globalSettings:
    - **settings** - все поля из файла globalSettings.json
    - **objMaps** - карта из папки Maps
4. Drawer:
    - **drawSymb(a, symb: str, pos: Vec3)** - рисует символ "symb" в позиции "pos" на матрице "a"
    - **drawSymbImage(a, img: str, pos: Vec3)** - рисует список символов, хранящихся в папке TextImages, с именем "img"
      в позиции "pos" на матрице "a"
5. NTEmapManager:
    - **loadLevel(mapname: str = "globalMap")** - загружает карту, хранящуюся в папке Maps, с именем "mapname"
    - **stopMainLoop(func)** - останавливает главный цикл, пробросив ошибку, но, перед этим, выполняет функцию "func"
6. NTEngineClasses:
    - **объект ui** - представление класса UI
    - **объект camera** - представление класса Camera
    - **класс UI**:
        - **add(text, createNewLine: bool) -> int** - добавляет новую строку в массив строк, поле "createNewLine"
          отвечает за создание новой строки в конце, возвращает позицию новой строки в массиве
        - **clearSpace(i: int, createNewLine: bool)** - очищает строку с номером "i", поле "createNewLine" отвечает за
          создание новой строки в конце
        - **changeSpace(i: int, text='', createNewLine=True)** - изменяет свойства строки с номером i на новые
    - класс Vec3:
        - **Vec3.dev_by_float(a, n=1)** - делит вектор "a" на число "n"
        - **Vec3.mult_by_float(a, n=0)** - умножает вектор "a" на число "n"
        - **Vec3.sum(a, b)** - сумма векторов "a" и "b"
        - **Vec3.substr(a, b)** - из вектора "a" вычестает вектор "b"
        - **Vec3.mult(a, b)** - умножает компоненты вектора "a" на компоненты вектора "b"
        - **Vec3.div(a, b)** - делит компоненты вектора "a" на компоненты вектора "b"
        - **Vec3.distance(v1, v2)** - расстояние между векторами "v1" и "v2"
        - **Vec3.dot(a, b)** - Скалярное произведение векторов "a" и "b"
        - **Vec3.reflect(rd, n)**
        - **length()** - длинна вектора
        - **abs()**
        - **norm()**
        - **sign()**
    - **класс Transform**:
        - **local_position: Vec3** - локальная позиция объекта
        - **collide: bool** - просчет столкновений
        - **beh: Behavior** - ссылка на поведение
        - **moweDir(Dir: Vec3)** - прибавить к позиции вектор "Dir", с поправкой на физику
        - **setLocalPosition(V: Vec3)** - переместить локальную позицию в верктор "V", с поправкой на физику
        - **getPosition()** - получить глобальную позицию объекта в мире
    - **класс Obj**:
        - **tr: Transform** - класс Transform
        - **symb: str** - отображаемый символ
    - **класс Drawer**:
        - **drawSymb(a, symb: str, pos: Vec3)** - используется для отрисовки символа "symb" на позиции "pos", работает
          только в "lateUpdate"
        - **clearSymb(a, pos: Vec3)** - используется для очищения символа на позиции "pos", работает только в "
          lateUpdate"
    - **класс Behavior**:
        - **isInstantiated: bool** - определяет был ли объект создан с помощью метода instantiate()
        - **update(self, a)** - вызывается каждое обновление мира
        - **start(self)** - вызывается в самом начале
        - **onCollide(self, collider: Transform)** - вызывается при соприкосновении с объектом
        - **lateUpdate(self, a):** - вызывается после "update"
        - **passSteps(frames: int)** - используется для полной остановки объекта на "frames" тиков
        - **passSeconds(secs: float)** - используется для полной остановки объекта на "secs" секунд
        - **instantiate(beh, Pos: Vec3) -> int** - используется для создания объектов в позиции "pos" с поведением "beh"
          , в "beh" нужно ставить тип, наследованный от Behavior, возвращает позицию созданного объекта в массиве
          объектов, пример кода: ```instantiate(Scripts.FireBall.FireBall, self.gameobject.tr.position)```
        - **destroy(beh)** - удаляет объект "beh" из мира
    - **clamp(num, min_value, max_value)** - простейшее ограничение переменной
    - **findNearObjByPos(V: Vec3, f: float, b=[])** - возвращает объекты в радиусе "f" к позиции "V", исключая все
      объекты из списка "b", туда нужно ставить объекты типа, который наследован от Behavior

# На этом всё! Спасибо за прочтение!
