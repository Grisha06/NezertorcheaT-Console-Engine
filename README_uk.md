# NezertorcheaT's Console Engine

## Вітаю вас у документації з NezertorcheaT's Console Engine!

Щоб спробувати тестовий проект, запустіть файл main.py.

Редактор мапи представлений списком json файлів у папці Maps.
Перше поле – це ім'я мапи.
Далі йдуть описи ігрових об'єктів, а конкретніше їх імен.
Всередині об'єктів знаходяться поля "**startPos**" та "**components**".
Перше – це уявлення початкової позиції як вектора.
Друге – це список компонентів.
У ньому можуть лежати будь-які об'єкти, типи яких успадковані від класу "Component".
На ньому можуть лежати властивості цих об'єктів.

## Тепер найцікавіше! Свої скрипти!

У папці Scripts ви можете створювати свої файли, подібні до наявних. Ваш скрипт має виглядати так:

````
#<imports>
from NTEngineClasses import *

class Name(Behavior):
    def start(self):
        #<code>
    
    def update(self, a):
        #<code>

    def onCollide(self, collider: Collider):
        pass

    def onDraw(self, a):
        #<ui_code>
        #<draw_code>: Drawer().drawSymb(a, "8", Vec3(1, 1))
        
````

### Пояснення звичайних методів та класів:

1. NTETime:
    - **getTime()** - повертає поточний кадр
2. ObjList:
    - **getObjs()** - отримати всі об'єкти
3. GlobalSettings:
    - **settings** - усі поля з файлу globalSettings.json
    - **objMaps** - мапи з папки Maps
5. NTEmapManager:
    - **loadLevel(mapname: str = "globalMap")** - завантажує мапку, що зберігається в папці Maps, з ім'ям "mapname"
    - **stopMainLoop(func)** - зупиняє головний цикл, прокинувши помилку, але, перед цим, виконує функцію "func"
6. NTEngineClasses:
    - **об'єкт ui** - представлення класу UI
    - **клас UI**:
        - **add(text, createNewLine: bool) -> int** - додає новий рядок у масив рядків, поле "createNewLine" відповідає за створення нового рядка в кінці, повертає позицію нового рядка в масиві
        - **clearSpace(i: int, createNewLine: bool)** - очищає рядок з номером "i", поле "createNewLine" відповідає за створення нового рядка в кінці
        - **changeSpace(i: int, text='', createNewLine=True)** - змінює властивості рядка з номером i на нові
        - **UI.printStrAtPos(s: str, x: int, y: int)** - малює рядок у консолі, **Увага!** Для відображення об'єктів в ігровому світі використовуйте клас "Drawer"!
        - **UI.printImageAtPos(img: str, x: int, y: int)** - малює зображення з ім'ям "img" у консолі, **Увага!** Для відображення об'єктів в ігровому світі використовуйте клас "Drawer"!
    - **клас Vec3**:
        - **Vec3.dev_by_float(a, n=1)** - оператор "**//**" - ділить вектор "a" на число "n"
        - **Vec3.mult_by_float(a, n=0)** - оператор "**%**" - множить вектор "a" на число "n"
        - **Vec3.sum(a, b)** - оператор "**+**" - сума векторів "a" та "b"
        - **Vec3.substr(a, b)** - оператор "**-**" - з вектора "a" віднімає вектор "b"
        - **Vec3.mult(a, b)** - оператор "*" - множить компоненти вектора "a" на компоненти вектора "b"
        - **Vec3.div(a, b)** - ділить компоненти вектора "a" на компоненти вектора "b"
        - **Vec3.distance(v1, v2)** - відстань між векторами "v1" та "v2"
        - **Vec3.dot(a, b)** - оператор "**" - Скалярний добуток векторів "a" та "b"
        - **Vec3.reflect(rd, n)**
        - **length()** - довжина вектора
        - **abs()**
        - **norm()**
        - **sign()**
    - **клас Obj**:
        - **isInstantiated: bool** - визначає, чи був об'єкт створений за допомогою методу instantiate()
        - **tr: Transform** - клас Transform
        - **GetComponent(typ: Component)** - дозволяє отримати компонент типу "typ"
        - **AddComponent(comp: Component)** - дозволяє створити компонент типу "comp"
        - **AddComponents(comps: list)** - дозволяє створити компоненти "comps", типу "Component"
        - **AddCreatedComponent(comp)** - дозволяє створити компонент "comp"
        - **GetAllComponentsOfType(typ: Component)** - дозволяє отримати всі компоненти типу "typ"
        - **RemoveComponent(typ: Component)** - дозволяє видалити компонент типу "typ"
        - **PopComponent(i: int)** - дозволяє видалити компонент на місці "i"
        - **Find(name: str)** - дозволяє знайти об'єкт на ім'я
        - **FindByTag(tag: str)** - дозволяє знайти об'єкт за тегом
        - **FindWithComponent(comp: Component)** - дозволяє знайти об'єкт за компонентом
        - **FindAllWithComponent(comp: Component)** - дозволяє знайти всі об'єкти з компонентом
        - **FindAllByTag(tag: str)** - дозволяє знайти всі об'єкти з тегом
    - **clamp(num, min_value, max_value)** - найпростіше обмеження змінної
    - **findAllObjsAtRad(V: Vec3, rad: float)** - повертає об'єкти в радіусі "rad" до позиції "V"
    - **findNearObjByRad(V: Vec3, rad: float)** - повертає найближчий об'єкт у радіусі "rad" до позиції "V"

### Пояснення компонентів:

Це були звичайні класи і методи, що використовуються повсюдно, а тепер йдуть ті, які я називатиму компонентами, оскільки всі успадковані від класу "Component".
Вони використовуються при описі поведінки об'єктів.
З ними можна взаємодіяти через методи класу "Obj".
Також у них є посилання на об'єкт до якого вони прив'язані.

1. **клас Transform**:
    - **local_position: Vec3** - локальна позиція об'єкта
    - **moweDir(Dir: Vec3)** - додати до позиції вектор "Dir"
    - **setLocalPosition(V: Vec3)** - перемістити локальну позицію у вектор "V"
    - **position** - отримати глобальну позицію об'єкта у світі
2. **клас Drawer**:
    - **drawSymb(a, symb: str, pos: Vec3)** - використовується для відображення символу "symb" на позиції "pos", працює тільки в "lateUpdate"
    - **clearSymb(a, pos: Vec3)** - використовується для очищення символу на позиції "pos", працює тільки в "onDraw"
3. **клас Camera**:
    - **offset** - зміщення камери від лівого кута, спочатку дорівнює половині розміру мапи, що відмальовується.
4. **клас BoxCollider**:
    - **height** - висота колайдера
    - **width** - ширина коллайдера
    - **collide** - дотик
5. **клас Behavior**:
    - **update(self, a)** - викликається кожне оновлення світу
    - **start(self)** - викликається на самому початку
    - **onCollide(self, collider: Collider)** - викликається при зіткненні з об'єктом
    - **lateUpdate(self, a):** - викликається після "update"
    - **onDraw(self, a):** - викликається після відтворення
    - **passSteps(frames: int)** - використовується для повної зупинки об'єкта на "frames" тиків
    - **passSeconds(secs: float)** - використовується для повної зупинки об'єкта на "secs" секунд
    - **instantiate(symb: str, Pos=Vec3(), comps=[]) -> Obj** - використовується для створення об'єктів у позиції "Pos" з компонентами "comps" та символом "symb"
    - **destroy(beh)** - видаляє об'єкт "beh" зі світу

### Поради:

1. На сцені має бути хоча б одна камера, якщо їх не буде, нічого не буде відмальовано.
2. Для визначення головної камери існує тег "**MainCamera**".
3. Не використовуйте методи з **ObjList**, замість них використовуйте **Obj.Find()** та ін.
4. Не використовуйте **NTETime**.
5. Колізія поки не реалізована, тому вам доведеться писати її самостійно, але є галочка, що відповідає за перетин об'єктів.
6. Не використовуйте **BoxCollider.side**.

# На цьому все! Дякую за прочитання!
