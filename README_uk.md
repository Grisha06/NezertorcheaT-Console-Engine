# NezertorcheaT's Console Engine

## Вітаю вас у документації з NezertorcheaT's Console Engine!

Щоб спробувати тестовий проект, запустіть файл main.py.  
  
Редактор мапи представлений списком json файлів у папці Maps.  
Перше поле – це ім'я мапи.  
Далі йдуть описи ігрових об'єктів, а конкретніше їх імен.  
Всередині об'єктів знаходяться поля "**startPos**" та "**components**".  
Перше – це уявлення початкової позиції як вектора.  
Друге – це список компонентів.  
У ньому можуть лежати будь-які об'єкти, типи яких успадковані від класу "Component".  
На ньому можуть лежати властивості цих об'єктів.  
  
Також редактор мапи представлений графічним скриптом, написаним на python kivy.  
Щоб його використати, потрібно запустити файл kivy_redactor.py.  
Приклад інтерфейсу:  
![](https://github.com/Grisha06/NezertorcheaT-Console-Engine/blob/main/README_images/image.jpg?raw=true)
Зліва ви бачите список наявних об'єктів.  
Кнопка Add New Object дозволить створити новий об'єкт.  
Кнопка **Save Map** дозволить зберегти мапу як .json файл.  
Натиснувши на один з об'єктів у списку, виберіть його.  
Посередині приблизна мапа, яка має вийти у грі.  
Натиснувши на один з об'єктів на мапі, ви його виберіть.  
Праворуч ви бачите панель властивостей.  
Верхні властивості є обов'язковими.  
А саме:  
**Name** - ім'я;  
**Layer** - шар відмальовування;  
**Tag** - тег.  
Ці властивості є обов'язковими для об'єкта.  
Також є обов'язковий для об'єкта компонент **Transform**.  
Його не можна видалити.  
Властивість **local_position** компонента **Transform** змінює локальну позицію об'єкта.  
Також зазвичай є компонент Drawer.  
Компоненти можна видалити, натиснувши кнопку **Delete**, поряд з ім'ям компонента.  
Пояснення компонентів є нижче.  
Кнопка **Add Component** дозволить додати один із наявних компонентів.  
Кнопка **Delete Object** дозволить видалити об'єкт.  

## Тепер найцікавіше! Свої скрипти!

У папці Scripts ви можете створювати свої файли, подібні до наявних. Ваш скрипт має виглядати так:  

````
#<imports>
від NTEngineClasses import *

class Name(Behavior):
    def start(self):
        #<code>
    
    def update(self, a):
        #<code>

    def onCollide(self, collider: Collider):
        #<code>

    def onDraw(self, a):
        #<ui_code>
        #<draw_code>: Drawer().drawSymb(a, "8", Vec3(1, 1))
        
````

### Пояснення звичайних методів та класів:

1. NTETime:
    - **getTime()** - повертає поточний кадр
2. ObjList:
    - **getObjs()** - отримати всі об'єкти
3. GlobalSettings:
    - **settings** - усі поля з файлу globalSettings.json
    - **objMaps** - мапи з папки Maps
4. NTEmapManager:
    - **loadLevel(mapname: str = "globalMap")** - завантажує мапу, що зберігається в папці Maps, з ім'ям "mapname"
    - **stopMainLoop(func)** - зупиняє головний цикл, прокинувши помилку, але, перед цим, виконує функцію "func"
5. NTEngineClasses:
    - **об'єкт ui** - представлення класу UI
    - **клас UI**:
        - **add(text, createNewLine: bool) -> int** - додає новий рядок у масив рядків, поле "createNewLine" відповідає за створення нового рядка в кінці, повертає позицію нового рядка в масиві
        - **clearSpace(i: int, createNewLine: bool)** - очищає рядок з номером "i", поле "createNewLine" відповідає за створення нового рядка в кінці
        - **changeSpace(i: int, text='', createNewLine=True)** - змінює властивості рядка з номером i на нові
        - **UI.printStrAtPos(s: str, x: int, y: int)** - малює рядок у консолі, **Увага!** Для відображення об'єктів в ігровому світі використовуйте клас "Drawer"!
        - **UI.printImageAtPos(img: str, x: int, y: int)** - малює зображення з ім'ям "img" у консолі, **Увага!** Для відображення об'єктів в ігровому світі використовуйте клас "Drawer"!
    - **клас Component**:
        - **gameobject: Obj** - посилання на об'єкт
    - **клас Vector3**:
        - оператор "**//**" - ділить вектор "a" на число "n"
        - оператор "*" - множить вектор "a" на число "b" - Скалярний добуток векторів "a" та "b"
        - оператор "**+**" - сума векторів "a" та "b"
        - оператор "**-**" - з вектора "a" віднімає вектор "b"
        - **Vector3.mult(a, b)** - множить компоненти вектора "a" на компоненти вектора "b"
        - **Vector3.div(a, b)** - ділить компоненти вектора "a" на компоненти вектора "b"
        - **Vector3.distance(v1, v2)** - відстань між векторами "v1" та "v2"
        - **Vector3.reflect(rd, n)**
        - **length: float** - довжина вектора
        - **norm: Vector3**
    - **клас Obj**:
        - **isInstantiated: bool** - визначає, чи був об'єкт створений за допомогою методу instantiate()
        - **tr: Transform** - клас Transform
        - **GetComponent(typ: Component)** - дозволяє отримати компонент типу "typ"
        - **AddComponent(comp: Component)** - дозволяє створити компонент типу "comp"
        - **AddComponents(comps: list)** - дозволяє створити компоненти "comps", типу "Component"
        - **AddCreatedComponent(comp)** - дозволяє створити компонент "comp"
        - **GetAllComponentsOfType(typ: Component)** - дозволяє отримати всі компоненти типу "typ"
        - **RemoveComponent(typ: Component)** - дозволяє видалити компонент типу "typ"
        - **PopComponent(i: int)** - дозволяє видалити компонент на місці "i"
        - **Find(name: str)** - дозволяє знайти об'єкт на ім'я
        - **FindByTag(tag: str)** - дозволяє знайти об'єкт за тегом
        - **FindWithComponent(comp: Component)** - дозволяє знайти об'єкт за компонентом
        - **FindAllWithComponent(comp: Component)** - дозволяє знайти всі об'єкти з компонентом
        - **FindAllByTag(tag: str)** - дозволяє знайти всі об'єкти з тегом
    - **clamp(num, min_value, max_value)** - найпростіше обмеження змінної
    - **findAllObjsAtRad(V: Vec3, rad: float)** - повертає об'єкти в радіусі "rad" до позиції "V"
    - **findNearObjByRad(V: Vec3, rad: float)** - повертає найближчий об'єкт у радіусі "rad" до позиції "V"

### Пояснення компонентів:

Це були звичайні класи і методи, що використовуються повсюдно, а тепер йдуть ті, які я називатиму.компонентами, оскільки всі успадковані від класу "Component".  
Вони використовуються при описі поведінки об'єктів.  
З ними можна взаємодіяти через методи класу "Obj".  
Також у них є посилання на об'єкт до якого вони прив'язані.  

1. **клас Transform**:
    - **local_position: Vec3** - локальна позиція об'єкта
    - **position: Vec3** - глобальна позиція об'єкту
    - **moweDir(Dir: Vec3)** - додати до позиції вектор "Dir"
    - **setLocalPosition(V: Vec3)** - перемістити локальну позицію у вектор "V"
2. **клас Drawer**:
    - **drawSymb(a, symb: str, pos: Vec3)** - використовується для відображення символу "symb" на позиції "pos", працює тільки в "lateUpdate"
    - **clearSymb(a, pos: Vec3)** - використовується для очищення символу на позиції "pos", працює тільки в "onDraw"
3. **клас Camera**:
    - **offset** - зміщення камери від лівого кута, спочатку дорівнює половині розміру мапи, що відмальовується.
4. **клас BoxCollider**:
    - **height** - висота колайдера
    - **width** - ширина коллайдера
    - **collide** - дотик
5. **клас RigidBody** – моя спроба реалізації фізики
6. **клас Behavior**:
    - **update(self, a)** - викликається кожне оновлення світу
    - **start(self)** - викликається на самому початку
    - **onCollide(self, collider: Collider)** - викликається при зіткненні з об'єктом
    - **lateUpdate(self, a):** - викликається після "update"
    - **onDraw(self, a):** - викликається після відтворення
    - **passSteps(frames: int)** - використовується для повної зупинки об'єкта на "frames" тиків
    - **passSeconds(secs: float)** - використовується для повної зупинки об'єкта на "secs" секунд
    - **instantiate(symb: str, Pos=Vec3(), comps=[]) -> Obj** - використовується для створення об'єктів у позиції "Pos" з компонентами "comps" та символом "symb"
    - **destroy(beh)** - видаляє об'єкт "beh" зі світу

### Поради:

1. На сцені має бути хоча б одна камера, якщо їх немає, нічого не буде відмальовано.   
2. Для визначення головної камери існує тег "MainCamera".   
3. Не використовуйте методи з **ObjList**, замість них використовуйте **Obj.Find()** та ін.   
4. Не використовуйте **NTETime**.   
5. Колізія поки що погано реалізована, тому вам доведеться писати її самостійно.   
7. Приклад реалізації колізії:   
````
class SomeBody(RigidBody):
    def updRB(self):
        for i in self.gameobject.transform.nears:
            for j in i.GetAllComponentsOfTypes(all_subclasses(RigidBody)):
                для jj в j.gameobject.GetAllComponentsOfType(Collider):
                    if jj.collide:
                        self.gameobject.transform.moveDir(Vector3.D2V(jj.angle))
````

# На цьому все! Дякую за прочитання!