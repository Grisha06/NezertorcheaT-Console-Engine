# NezertorcheaT Console Engine

## Вітаю вас у документації з NezertorcheaT Console Engine!

І почнемо мабуть з того, що, щоб працювати, вам знадобиться встановлений Python на комп'ютер і завантажений репозиторій самого проекту в окремій папці.  

Щоб спробувати тестовий проект, запустіть файл main.py.  

Редактор мапи відкривається запуском файлу redactor.py.
Поля "**Height**" та "**Width**" відповідають за розмір ігрового поля.
Написавши туди цифри більше 1 і натиснувши "**Set Grid Size**", ви збережете ці значення у файл globalSettings.json.
Кнопка "**Save Map**" збереже мапу у файл globalMap.json.
Натискаючи на клітинки, відкриється меню створення об'єкта, але спочатку потрібно вписати туди ім'я одного з класів, що лежать у папці.
Scripts.

Далі буде вікно редактора властивостей, в ньому обов'язково мають бути властивості: "**name**", "**spawnposx**", "**spawnposy**", "**symbol**", "**parent**"та "**collide**". Також ви можете додати ці властивості в скриптах.

Властивість "**name**" відповідає за ім'я і якщо введене ім'я існує, об'єкт із цим ім'ям буде перезаписано.  
Властивість "**spawnposx**" відповідає за початкову локальну позицію об'єкта по осі X.  
Властивість "**spawnposy**" відповідає за початкову локальну позицію об'єкта по осі Y.  
Властивість "**symbol**" відповідає за символ об'єкта у світі.  
Властивість "**collide**" відповідає за можливість зіткнення з іншими об'єктами.  
Властивість "**parent**" відповідає за батька об'єкта та приймає ім'я об'єкта.  
Властивість із закінченням "**_name**" приймає ім'я об'єкта і буде розглянуто як цей об'єкт.  
Кнопка **Save** відповідає за збереження об'єкта на карті.  

Це поки що весь функціонал редактора карти.

## Тепер найцікавіше! Свої скрипти!

У папці Scripts ви можете створювати свої файли, подібні до наявних. Ваш скрипт має виглядати так:

````
#<imports>
from NTEngineClasses import *

class Name(Behavior):
    spawnposx = 0
    spawnposy = 0
    symbol = '@'
    collide = True

    def start(self):
        #<code>
    
    def update(self, a):
        #<code>
        if not self.isInstantiated:
            #<ui_code>
    def onCollide(self, collider: Transform):
        pass
    def lateUpdate(self, a):
        #<Drawer().drawSymb(a, "8", Vec3(1, 1))>
        
````

### Пояснення методів:

1. NTETime:
    - **getTime()** - повертає поточний кадр
2. ObjList:
    - **getObj(i: int)** - отримати об'єкт
    - **getObjs()** - отримати всі об'єкти
    - **getObjByName(name: str)** - отримати об'єкт з ім'ям "name"
    - **getObjsByBeh(btype):** - отримати всі об'єкти з типом "btype"
3. GlobalSettings:
    - **settings** - усі поля з файлу globalSettings.json
    - **objMaps** - картка з папки Maps
4. Drawer:
    - **drawSymb(a, symb: str, pos: Vec3)** - малює символ "symb" у позиції "pos" на матриці "a"
    - **drawSymbImage(a, img: str, pos: Vec3)** - малює список символів, що зберігаються в папці TextImages, з ім'ям "img"
      у позиції "pos" на матриці "a"
5. NTEmapManager:
    - **loadLevel(mapname: str = "globalMap")** - завантажує мапу, що зберігається в папці Maps, з ім'ям "mapname"
    - **stopMainLoop(func)** - зупиняє головний цикл, прокинувши помилку, але, перед цим, виконує функцію "func"
6. NTEngineClasses:
    - **об'єкт ui** - представлення класу UI
    - **об'єкт camera** - представлення класу Camera
    - **клас UI**:
        - **add(text, createNewLine: bool) -> int** - додає новий рядок у масив рядків, поле "createNewLine"
          відповідає за створення нового рядка в кінці, повертає позицію нового рядка в масиві
        - **clearSpace(i: int, createNewLine: bool)** - очищає рядок з номером "i", поле "createNewLine" відповідає за
          створення нового рядка наприкінці
        - **changeSpace(i: int, text='', createNewLine=True)** - змінює властивості рядка з номером i на нові
    - **клас Vec3**:
        - **Vec3.dev_by_float(a, n=1)** - ділить вектор "a" на число "n"
        - **Vec3.mult_by_float(a, n=0)** - множить вектор "a" на число "n"
        - **Vec3.sum(a, b)** - сума векторів "a" та "b"
        - **Vec3.substr(a, b)** - з вектора "a" вичістає вектор "b"
        - **Vec3.mult(a, b)** - множить компоненти вектора "a" на компоненти вектора "b"
        - **Vec3.div(a, b)** - ділить компоненти вектора "a" на компоненти вектора "b"
        - **Vec3.distance(v1, v2)** - відстань між векторами "v1" та "v2"
        - **Vec3.dot(a, b)** - Скалярний добуток векторів "a" та "b"
        - **Vec3.reflect(rd, n)**
        - **length()** - довжина вектора
        - **abs()**
        - **norm()**
        - **sign()**
    - **клас Transform**:
        - **local_position: Vec3** - локальна позиція об'єкта
        - **collide: bool** - прорахунок зіткнень
        - **beh: Behavior** - посилання на поведінку
        - **moweDir(Dir: Vec3)** - додати до позиції вектор "Dir", з поправкою на фізику
        - **setLocalPosition(V: Vec3)** - перемістити локальну позицію у верктор "V", з поправкою на фізику
        -**getPosition()** - отримати глобальну позицію об'єкта у світі
    - **клас Obj**:
        - **tr: Transform** - клас Transform
        - **symb: str** - символ, що відображається
    - **клас Drawer**:
        - **drawSymb(a, symb: str, pos: Vec3)** - використовується для відображення символу "symb" на позиції "pos", працює
          тільки в "lateUpdate"
        - **clearSymb(a, pos: Vec3)** - використовується для очищення символу на позиції "pos", працює тільки в "
          lateUpdate"
    - **клас Behavior**:
        - **isInstantiated: bool** - визначає чи був об'єкт створений за допомогою методу instantiate()
        - **update(self, a)** - викликається кожне оновлення світу
        - **start(self)** - викликається на самому початку
        - **onCollide(self, collider: Transform)** - викликається при зіткненні з об'єктом
        - **lateUpdate(self, a):** - викликається після "update"
        - **passSteps(frames: int)** - використовується для повної зупинки об'єкта на "frames" тиків
        - **passSeconds(secs: float)** - використовується для повної зупинки об'єкта на "secs" секунд
        - **instantiate(beh, Pos: Vec3) -> int** - використовується для створення об'єктів у позиції "pos" з поведінкою "beh"
          , в "beh" потрібно ставити тип, успадкований від Behavior, повертає позицію створеного об'єкта в масиві
          об'єктів, приклад коду: ``instantiate(Scripts.FireBall.FireBall, self.gameobject.tr.position)```
        - **destroy(beh)** - видаляє об'єкт "beh" зі світу
    - **clamp(num, min_value, max_value)** - найпростіше обмеження змінної
    - **findNearObjByPos(V: Vec3, f: float, b=[])** - повертає об'єкти в радіусі "f" до позиції "V", виключаючи всі
      об'єкти зі списку "b", туди потрібно ставити об'єкти типу, успадкованого від Behavior

# На цьому все! Дякую за прочитання!
